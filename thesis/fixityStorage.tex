\section{General}
Fixity can be stored in multiple places but the keypoint of it is to have some kind of reference to the object and a cryptographic hash value with it to control if the object has changed at a certain time interval. Another keypoint o fixity storages is that it should not be vulnerable to unauthorized access.
\section{Solidity}
In solidity there exists a mapping type, which is exactly what is needed for the fixity storage. The mapping type is basically a hash map consisting of a key => value, where in our case the key is a integer representing the pool id and the vlue is a bytes32 object representing the sha256 value of the pool. Since pretty much everything needed is available native in the solidity language the smart contract of the fixity storage is rather sparse. The smart ccontract has one mapping object with a getter and setter to access the map. The cost for deploying the smart contract can be dreived from the used variables in solidity. 
\section{Cost}
The exapt computation o deployment cost is as follows: todo
For example the upload process can be handledat time of the day where there is less trafic on the ethereum blockchain, which will result in overall  less operation cost in Ether tokens and Dollar respectively. A cron expression could be used client sided to upload the pools on the least used days of the week. See figure \ref{fig:daysOfWeek}.
The deployment cost of the smart contract is also dependent on the variable types used to persist data.
\section{Access}
In solidity one can require a certrain address to acess a function, the keyword requires can be used  so that a transaction from a unknown address can be reverted and only the archive itself can update the mapping vlue in the smart contract. An interestng topic is also how the private key in the archive is maanged, which is not part of this thesis but something like a multisignature wallet may be used to split the oversight of the owner address in the contract. Since the entity which controls the privte key of the smart contract is able to perform update operations which can lead to history forgery. Therefore the key usermanagement of the smart contract can be used as a next steps in further research. For this thesis i assume that the private key is well managed andeach transaction coming from the master address is legitim.
\section{Transaction Throughput}
Important because archive can have bulks over 1 million objects
\section{Deployment}
I decided to use truffle to develop, test and deploy the smart contract for the fixity-storage. Truffle is a development environment, testing framework and asset pipeline for blockchains using the Ethereum Virtual Machine. Truffle brings built-in smart contract compilation, linking, deployment and binary management with automated contract testing. The reasoning behind my decision is that, truffle has all the tools needed to implement a smart contract in one package and therefore reduced complexity in the development process. In the first steps I even used the user-interface "Ganache" to get a better feeling for the ethereum blockchain. It allows you to click through your smart contract and look at the state variables or functions to validate that your smart contract was successfully deployed. Ganache has a massive disadvantage when doing high throughput computing, it seems that it is no suited to do 10.000 transactions in a python for loop. Therefore I only used it in the beginning of the experiment where I only persisted about 10 objects at a time without problems. For high throughput computing, truffle offers a command line tool to interact with the blockchain. The command line tool was resistent and showed no weakness when persisting 10.000 objects.
Truffle also allows to config other networks, e.g. the ropsten test network, which can be defined as a parameter in the deployment process. The deployment requires to have some ether token in your account to pay the miner to integrate your smart contract in a block. 